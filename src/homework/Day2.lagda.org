#+begin_src agda2

module homework.Day2 where

open import Prelude
open import Day1
open import Day2

#+end_src

* Ð—Ð°Ð´Ð°Ñ‡Ð° 1 (â˜…)
Ð’ÑÐ¿Ð¾Ð¼Ð½Ð¸Ñ‚Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ¾Ð² Ð¸ Ð¿Ð¾ Ð°Ð½Ð°Ð»Ð¾Ð³Ð¸Ð¸ ÑÐ¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ Ñ‚Ð¸Ð¿Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…:
  - Ð‘Ð¸Ð½Ð°Ñ€Ð½Ñ‹Ðµ Ð´ÐµÑ€ÐµÐ²ÑŒÑ, Ñ…Ñ€Ð°Ð½ÑÑ‰Ð¸Ðµ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð»ÑŒÐ½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð² Ð»Ð¸ÑÑ‚ÑŒÑÑ….
  - Ð‘Ð¸Ð½Ð°Ñ€Ð½Ñ‹Ðµ Ð´ÐµÑ€ÐµÐ²ÑŒÑ, Ñ…Ñ€Ð°Ð½ÑÑ‰Ð¸Ðµ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð»ÑŒÐ½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð² ÑƒÐ·Ð»Ð°Ñ….
#+begin_src agda2

data Treeâ‚— (A : Typeâ‚€) : Typeâ‚€ where
  -- Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ ÐºÐ¾Ð½ÑÑ‚Ñ€ÑƒÐºÑ‚Ð¾Ñ€Ñ‹

data Treeâ‚™ (A : Typeâ‚€) : Typeâ‚€ where
  -- Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ ÐºÐ¾Ð½ÑÑ‚Ñ€ÑƒÐºÑ‚Ð¾Ñ€Ñ‹

#+end_src

* Ð—Ð°Ð´Ð°Ñ‡Ð° 2 (â˜…)
ÐÐ°Ð¿Ð¸Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð¾Ð±Ñ…Ð¾Ð´Ð° (left to right) Ð´Ð»Ñ Ñ‚Ð°ÐºÐ¸Ñ… Ð´ÐµÑ€ÐµÐ²ÑŒÐµÐ², Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÐ¾Ð±Ñ€Ð°Ñ‚ÑŒ
ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð´ÐµÑ€ÐµÐ²Ð° Ð² ÑÐ¿Ð¸ÑÐ¾Ðº.
#+begin_src agda2

traverseâ‚— : {A : Typeâ‚€} â†’ Treeâ‚— A â†’ List A
traverseâ‚— = {!!}

traverseâ‚™ : {A : Typeâ‚€} â†’ Treeâ‚™ A â†’ List A
traverseâ‚™ = {!!}

#+end_src

* Ð—Ð°Ð´Ð°Ñ‡Ð° 3 (â˜…â˜…â˜…)
Ð’ Haskell Ð¼Ð¾Ð¶Ð½Ð¾ Ð²ÑÑ‚Ñ€ÐµÑ‚Ð¸Ñ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ ~$~, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑŽÑ‰ÑƒÑŽ Ð½Ðµ Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð»Ð¸ÑˆÐ½Ð¸Ðµ ÑÐºÐ¾Ð±ÐºÐ¸,
Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÑÑ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð¾Ð´Ð½Ñƒ Ð·Ð° Ð´Ñ€ÑƒÐ³Ð¾Ð¹. Ð’ ÑÐ·Ñ‹ÐºÐµ Ñ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ñ‹Ð¼Ð¸ Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸ ÐµÑ‘
ÑÐ¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ð° Ð±Ð¾Ð»ÐµÐµ Ð¾Ð±Ñ‰Ð°Ñ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð½Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾ Ð¾Ð±Ñ‰ÑƒÑŽ ÑÐ¸Ð³Ð½Ð°Ñ‚ÑƒÑ€Ñƒ Ð´Ð»Ñ
Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° ÐºÐ¾Ð¼Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹.
#+begin_src agda2

-- non-dependent
_$â‚•_ : {A B : Typeâ‚€} â†’ (A â†’ B) â†’ A â†’ B
f $â‚• x = f x

-- dependent
-- _$_ : {A : Typeâ‚€} {B : A â†’ Typeâ‚€} â†’ (f : (a : A) â†’ B a) â†’ (x : A) â†’ B x
_$_ : {a b : Level} {A : Type a} {B : A -> Type b} -> ((a : A) -> B a) -> (a : A) -> B a
f $ x = f x

-- ...now, the question is: is it possible for B's _level_ to be A-polymorphic?
-- I'm guessing "what, no, are you fucking insane", but it costs us nothing to try

-- question the first: is it possible to define functions _to Level_?
â„•-to-Level : â„• -> Level -- ...well `->` seems to allow this, so....
â„•-to-Level zero = 0â„“
â„•-to-Level (suc n) = suc-â„“ (â„•-to-Level n)
-- .....and....._apparently_ this is valid! horrifying!
-- I think this works because `Level : Set`. ok then!!!
-- in that case, 
_$â„“_ : {aâ„“ : Level} {A : Type aâ„“} {bâ„“ : A -> Level}
  {B : (a : A) -> Type (bâ„“ a)} -> ((a : A) -> B a) -> (a : A) -> B a
f $â„“ x = f x

-- ...well uh, and can we define a function....that can go arbitrarily high?
-- f : (n : â„•) -> Type (â„•-to-Level n)
-- f n = {! !}
-- ...in principle, absolutely; in practice we need either a level-polymorphic type 
-- (we have none presently), or use Type itself, which is of course `Type : (l : Level) -> Type (suc-â„“ l)

-- oh, and by the way: we can't define datatypes of levels dependeing on indices
-- data Wat : (n : â„•) -> Type (â„•-to-Level n) where
-- but parameters go fine!
data Wat (n : â„•) : Type (â„•-to-Level n) where
  W : Wat n
-- and here we at last touch SetÏ‰!
-- not in that Wat is SetÏ‰-typed; that its type is SetÏ‰-typed.
-a : Agda.Primitive.SetÏ‰
-a = (n : â„•) -> Type (â„•-to-Level n)
-- ...although on reflection that can be done easier.
-b : Agda.Primitive.SetÏ‰
-b = (l : Level) -> Type l
-- but if you thought SetÏ‰ : SetÏ‰, you would be mistaken!
-- it is : SetÏ‰â‚ ofc.
-- ..well now we could define a func that just returns Wat, or W, but what's the point really.
-- anyway.

-- non-dependent
_âˆ˜â‚•_ : {A B C : Typeâ‚€} â†’ (B â†’ C) â†’ (A â†’ B) â†’ (A â†’ C)
(g âˆ˜â‚• f) x = g (f x)

-- dependent
_âˆ˜_ : {A : Typeâ‚€} {B : A -> Typeâ‚€} {C : (a : A) -> B a -> Typeâ‚€} ->
  ({a : A} -> (b : B a) -> C a b ) -> 
  (f : (a : A) -> B a) -> 
  (a : A) -> C a (f a)
(g âˆ˜ f) x = g (f x)

-- level-parametric
_âˆ˜â„“_ : {aâ„“ bâ„“ câ„“ : Level} {A : Type aâ„“} {B : A -> Type bâ„“} {C : (a : A) -> B a -> Type câ„“} ->
  ({a : A} -> (b : B a) -> C a b ) -> 
  (f : (a : A) -> B a) -> 
  (a : A) -> C a (f a)
(g âˆ˜â„“ f) x = g (f x)

-- level-dependent
_âˆ˜ð’¹â„“_ : 
  {aâ„“ : Level} {A : Type aâ„“} 
  -- what's stopping us from making bâ„“ : Level -> A -> Level? ......restraint, let's say.
  {bâ„“ : A -> Level} {B : (a : A) -> Type (bâ„“ a)}  
  {câ„“ : (a : A) -> B a -> Level} {C : (a : A) -> (b : B a) -> Type (câ„“ a b)} ->
  ({a : A} -> (b : B a) -> C a b ) -> 
  (f : (a : A) -> B a) -> 
  (a : A) -> C a (f a)
(g âˆ˜ð’¹â„“ f) x = g (f x)
-- .....what if we had more power?
_âˆ˜ð’¹â„“Â²_ : 
  -- {aâ„“ : Level} 
  {A  : (â„“ : Level) -> Type â„“} 
  {bâ„“ : (â„“ : Level) -> A â„“ -> Level} 
  {B  : (â„“ : Level) -> (a : A â„“) -> Type (bâ„“ â„“ a)}
  {câ„“ : (â„“ : Level) -> (a : A â„“) -> B â„“ a -> Level} 
  {C : (â„“ : Level) -> (a : A â„“) -> (b : B â„“ a) -> Type (câ„“ â„“ a b)}
  {â„“ : Level} ->
  ({a : A â„“} -> (b : B â„“ a) -> C â„“ a b ) -> 
  (f : (a : A â„“) -> B â„“ a) -> 
  (a : A â„“) -> C â„“ a (f a)
(g âˆ˜ð’¹â„“Â² f) x = g (f x)
-- that's....different though; we parametrized everything, 
-- not increased dependency of following params on the previous.


#+end_src
Ð­Ñ‚Ñƒ Ð·Ð°Ð´Ð°Ñ‡Ñƒ Thierry Coquand Ð´Ð°Ð²Ð°Ð» ÐºÐ¾Ð¼Ñƒ-Ñ‚Ð¾ Ð½Ð° Ð·Ð°Ñ‰Ð¸Ñ‚Ðµ Ð´Ð¸Ð¿Ð»Ð¾Ð¼Ð° :-)

* Ð—Ð°Ð´Ð°Ñ‡Ð° 4 (â˜…â˜…)
Ð¢ÐµÐ¿ÐµÑ€ÑŒ Ð¼Ñ‹ Ð·Ð½Ð°ÐµÐ¼, Ð¿Ð¾Ñ‡ÐµÐ¼Ñƒ Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð´Ð¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¿Ð¾Ð»Ð¾Ð²Ð¸Ð½ÐºÑƒ Ñ‚Ð°Ð²Ñ‚Ð¾Ð»Ð¾Ð³Ð¸Ð¸ ~contra~ Ð¸Ð·
Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð³Ð¾ Ð´Ð·. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð´Ð¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÐµÑ‘, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ Ð·Ð°ÐºÐ¾Ð½ Ð¸ÑÐºÐ»ÑŽÑ‡Ñ‘Ð½Ð½Ð¾Ð³Ð¾ Ñ‚Ñ€ÐµÑ‚ÑŒÐµÐ³Ð¾.

#+begin_src agda2

contraâ€² : {A B : ð“¤â‚€} â†’ (lem : (Î  X êž‰ ð“¤â‚€ , Dec X)) â†’ (Â¬ B â‡’ Â¬ A) â†’ (A â‡’ B)
contraâ€² {B = B} lem Â¬Bâ‡’Â¬A a with lem B 
... | injâ‚ b  = b
... | injâ‚‚ Â¬B = âŠ¥-elim (Â¬Bâ‡’Â¬A Â¬B a)
  where 
  âŠ¥-elim : {l : Level} {W : Type l} -> âŠ¥ -> W
  âŠ¥-elim ()

#+end_src

* Ð—Ð°Ð´Ð°Ñ‡Ð° 5 (â˜…â˜…â˜…)
Ð“Ð¾Ñ‚Ñ‚Ñ„Ñ€Ð¸Ð´ Ð›ÐµÐ¹Ð±Ð½Ð¸Ñ† Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸Ð·Ð¾Ð²Ð°Ð» Ñ€Ð°Ð²ÐµÐ½ÑÑ‚Ð²Ð¾ Ñ‚Ð°ÐºÐ¸Ð¼ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð¼:
Ð´Ð»Ñ Ð»ÑŽÐ±Ñ‹Ñ… ~x~ Ð¸ ~y~, Ð¾Ð½Ð¸ Ñ€Ð°Ð²Ð½Ñ‹ Ñ‚Ð¾Ð³Ð´Ð° Ð¸ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾Ð³Ð´Ð°, ÐºÐ¾Ð³Ð´Ð° Ð´Ð»Ñ Ð»ÑŽÐ±Ð¾Ð³Ð¾ Ð¿Ñ€ÐµÐ´Ð¸ÐºÐ°Ñ‚Ð° ~P~,
~P(x)~ Ð»Ð¾Ð³Ð¸Ñ‡ÐµÑÐºÐ¸ ÑÐºÐ²Ð¸Ð²Ð°Ð»ÐµÐ½Ñ‚Ð½Ð¾ ~P(y)~.

Ð¡Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ ÑÑ‚Ð¾ Ñ€Ð°Ð²ÐµÐ½ÑÑ‚Ð²Ð¾ Ð¸ Ð¿Ð¾ÐºÐ°Ð¶Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð¸Ð· Ñ€Ð°Ð²ÐµÐ½ÑÑ‚Ð²Ð° Ð¿Ð¾ Ð›ÐµÐ¹Ð±Ð½Ð¸Ñ†Ñƒ ÑÐ»ÐµÐ´ÑƒÐµÑ‚ Ð¸ Ð½Ð°ÑˆÐµ
Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð²ÐµÐ½ÑÑ‚Ð²Ð°, Ð¸ Ð½Ð°Ð¾Ð±Ð¾Ñ€Ð¾Ñ‚.

#+begin_src agda2

_â‰¡â‚—_ : {l : Level} {A : Type l} â†’ (x y : A) â†’ Type (suc-â„“ l)
_â‰¡â‚—_ {l} {A} x y = âˆ€ (P : A -> Type l) -> P x â‡” P y

leibniz-to-martin-lÃ¶f : {A : Typeâ‚€} (x y : A) â†’ x â‰¡â‚— y â†’ x â‰¡ y
leibniz-to-martin-lÃ¶f x y xâ‰¡â‚—y = fst (xâ‰¡â‚—y (x â‰¡_)) (refl x)

martin-lÃ¶f-to-leibniz : {A : Typeâ‚€} (x y : A) â†’ x â‰¡ y â†’ x â‰¡â‚— y
martin-lÃ¶f-to-leibniz x y (refl .x) = Î» P â†’ (Î» x â†’ x) , (Î» x â†’ x)

-- the weird thing is that we do not need â†” to get the biimplication!
-- -> is enough.
-- ....so maybe, if we tried to do the full iso, mere implication would be the correct equivalent?

record _â‰…_ {a b : _} (A : Type a) (B : Type b) : Type (a âŠ” b) where
  constructor MkIso
  field
    to : A -> B
    from : B -> A
    toâˆ˜from : (a : A) -> from (to a) â‰¡ a
    fromâˆ˜to : (b : B) -> to (from b) â‰¡ b

-- ...hmm. note that we can't internalize level of P. ok then.
-- .....and neither we can unbind it! then from doesn't work! o*k*, let's nail them to the same level.

postulate 
  ext : âˆ€ {a b} {A : Type a} {B : A -> Type b} -> 
    {f g : (a : A) -> B a} -> (âˆ€ a -> f a â‰¡ g a) -> f â‰¡ g

-- apparently mere -> does not work! we get stuck at fromâˆ˜to, not particularly comprehensibly.
-- â‰¡-Equiv : âˆ€ {a} {A : Type a} -> (x y : A) -> (x â‰¡ y) â‰… âˆ€ (P : A -> Type a) -> P x -> P y
-- â‰¡-Equiv x y = MkIso 
--   (Î» {(refl .x) P Px â†’ Px })
--   (Î» xâ‰¡â‚—y â†’ xâ‰¡â‚—y (x â‰¡_) (refl x)) 
--   (Î» {(refl .x) â†’ refl (refl x)})
--   Î» xâ‰¡â‚—y â†’ ext Î» {P â†’ ext Î» Px â†’ {!   !}}

congâ‚‚ : âˆ€ {aâ„“ bâ„“ câ„“} {A : Type aâ„“} {B : Type bâ„“} {C : Type câ„“} 
  {a x : A} {b y : B} ->
  (f : A -> B -> C) -> (a â‰¡ x) -> (b â‰¡ y) -> f a b â‰¡ f x y
congâ‚‚ f (refl _) (refl _) = refl _

-- -- ok, now both ways.
-- â‰¡-Equiv : âˆ€ {a} {A : Type a} -> (x y : A) -> (x â‰¡ y) â‰… âˆ€ (P : A -> Type a) -> P x â‡” P y
-- â‰¡-Equiv x y = MkIso 
--   (Î» {(refl .x) â†’ Î» P â†’ (Î» x â†’ x) , (Î» x â†’ x)})
--   (Î» Ã—â‰¡â‚—y â†’ fst (Ã—â‰¡â‚—y (_â‰¡_ x)) (refl x))
--   (Î» {(refl .x) â†’ refl (refl x)})
--   -- ah shit here we go again.
--   Î» {xâ‰¡â‚—y â†’ ext Î» {P â†’ {!   !}}}



#+end_src

* Ð—Ð°Ð´Ð°Ñ‡Ð° 6 (â˜…â˜…)
ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚Ðµ ÑÐ²Ð¾Ð¹ÑÑ‚Ð²Ð° Ñ‡Ñ‘Ñ‚Ð½Ð¾ÑÑ‚Ð¸ Ð¸ Ð½ÐµÑ‡Ñ‘Ñ‚Ð½Ð¾ÑÑ‚Ð¸ Ð´Ð»Ñ Ð½Ð°Ñ‚ÑƒÑ€Ð°Ð»ÑŒÐ½Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ». ÐŸÐ¾ÐºÐ°Ð¶Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾
Ñ‡Ñ‘Ñ‚Ð½Ð¾ÑÑ‚ÑŒ Ñ€Ð°Ð·Ñ€ÐµÑˆÐ¸Ð¼Ð° Ð´Ð»Ñ Ð»ÑŽÐ±Ð¾Ð³Ð¾ Ð½Ð°Ñ‚ÑƒÑ€Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ñ‡Ð¸ÑÐ»Ð°.

#+begin_src agda2

Even : â„• â†’ Typeâ‚€
Even  = {!!}

Odd : â„• â†’ Typeâ‚€
Odd n = {!!}

even-dec : Î  n êž‰ â„• , Dec (Even n)
even-dec = {!!}

#+end_src

* Ð—Ð°Ð´Ð°Ñ‡Ð° 7 (â˜…â˜…)
Ð¢ÐµÐ¿ÐµÑ€ÑŒ Ð²Ñ‹ ÑÐ¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð¿Ñ€Ð¾Ð±Ð¾Ð²Ð°Ñ‚ÑŒ Ð´Ð¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÑƒÑŽ Ñ‚ÐµÐ¾Ñ€ÐµÐ¼Ñƒ:
#+begin_src agda2

hmm : Î  m êž‰ â„• , Î  n êž‰ â„• , (Even m âˆ§ Even n âˆ§ n > m â‡’ (Î£ k êž‰ â„• , k > m âˆ§ n > k âˆ§ Odd k))
hmm = {!!}

#+end_src
    