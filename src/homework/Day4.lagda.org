#+begin_src agda2

{-# OPTIONS --guardedness #-}
module homework.Day4 where

open import Prelude
open import Day4

open import Data.Bool using (false; true) renaming (Bool to 𝔹; _∧_ to _&&_; _∨_ to _||_)
open import Data.List using (List; []; _∷_; _++_; length)
open import Data.List.Membership.Propositional using (_∈_)
open import Data.List.Relation.Unary.All using (All)
open import Data.List.Relation.Unary.Any using (here; there)
open import Data.Nat using (ℕ; zero; suc; _+_) renaming (_≤_ to _≤ₙ_)
open import Relation.Binary using (Rel; IsPartialOrder)
open import Relation.Nullary using (¬_; Reflects; yes; no)

#+end_src

* Задача 1 (⋆⋆)
Предполагается, что вы знакомы с понятием /[[https://en.wikipedia.org/wiki/Partially_ordered_set][частичного порядка]]/. 
Определите /неубывающие (отсортированные) списки/.

#+begin_src agda2

record PartialOrder (A : Type ℓ) : Type (suc-ℓ ℓ) where
  field
    _≤_ : Rel A ℓ
    ipo : IsPartialOrder _≡_ _≤_
open PartialOrder ⦃ ... ⦄

-- возвращает все следующие за `t` элементы
nextElems : {A : Type ℓ}
            {t : A} {xs : List A}
            (p : t ∈ xs) → List A
nextElems {xs = _ ∷ xs′} (here  _) = xs′
nextElems {xs = _ ∷ _  } (there p) = nextElems p

-- наивное определение отсортированности: список `xs` отсортирован, если для любого
-- элемента `t`, лежащего в `xs`, t меньше или равен всем последующим элементам
is-sorted : {A : Type ℓ}
            ⦃ po : PartialOrder A ⦄
            (xs : List A) → Type ℓ
is-sorted {_} {A} xs = {t : A} (p : t ∈ xs) → All (t ≤_) (nextElems p)

-- давайте сделаем отдельный тип, элементами которого будут _только_ отсортированные списки
SortedList : (A : Type ℓ) ⦃ po : PartialOrder A ⦄ → Type ℓ
SortedList A = Σ (List A) is-sorted

forget-naive : {A : Type ℓ} ⦃ po : PartialOrder A ⦄ →
               SortedList A → List A
forget-naive = fst

validate-naive : {A : Type ℓ}
                 ⦃ po : PartialOrder A ⦄
                 (xsₛ : SortedList A) → is-sorted (forget-naive xsₛ)
validate-naive = snd

#+end_src


* Задача 2 (⋆⋆⋆⋆)
Теперь определите отсортированные списки с помощью индуктивного предиката.

#+begin_src agda2

data IsSorted {A : Type ℓ} ⦃ po : PartialOrder A ⦄ : List A → Type ℓ where
  -- какие есть принципиально разные случаи отсортированности списков?
  nil  : IsSorted []
  sing : ∀ a -> IsSorted (a ∷ [])
  ext  : ∀ a₁ a₂ as -> a₁ ≤ a₂ -> IsSorted (a₂ ∷ as) -> IsSorted (a₁ ∷ a₂ ∷ as)

SortedListᵢ : (A : Type ℓ) ⦃ po : PartialOrder A ⦄ → Type ℓ
SortedListᵢ A = Σ (List A) IsSorted

forgetᵢ : {A : Type ℓ} ⦃ po : PartialOrder A ⦄ →
          SortedListᵢ A → List A
forgetᵢ = fst


validateᵢ : {A : Type ℓ}
            ⦃ po : PartialOrder A ⦄
            (xsₛ : SortedListᵢ A) → is-sorted (forgetᵢ xsₛ)
-- wait, where's the nil case?
validateᵢ (xs , sing a) {t} (here px) = All.[]
validateᵢ (.(a₁ ∷ a₂ ∷ as) , ext a₁ a₂ as a₁≤a₂ ISa₂∷as) {.a₁} (here refl) =
  a₁≤a₂ All.∷ All.map I (validateᵢ (a₂ ∷ as , ISa₂∷as) (here refl))
  where
    open import Data.List.Relation.Unary.All as All
    I : ∀ {a} -> a₂ ≤ a -> a₁ ≤ a
    I a₂≤a = IsPartialOrder.trans ipo a₁≤a₂ a₂≤a
    -- II : All (a₂ ≤_) as
    -- II = validateᵢ (a₂ ∷ as , ISa₂∷as) (here refl)
validateᵢ (.(a₁ ∷ a₂ ∷ as) , ext a₁ a₂ as x snd₁) {t} (there p) =
  validateᵢ (a₂ ∷ as , snd₁) p

#+end_src


* Задача 3 (⋆⋆⋆⋆⋆)
Можно ли напрямую определить отсортированные списки как индуктивный тип?
Для вдохновения почитайте [[https://personal.cis.strath.ac.uk/conor.mcbride/Pivotal.pdf][How to keep your neighbours in order]].

A: 
See: Day4.SortedListHard.agda. it's fun!
....following the paper, we pose that the question is not whether we _can_; of course we can.
the real question is: how to define inherently-sorted lists so as to provide a convenient API?
e.g. : end-user programmers (including us) would rather....not prove anything they don't strictly need.
you'd be surprised how few things you _do_ need!
It turns out `Dichotomous _≤_` is enough to construct, insert, rotate, merge, append...
(----NB: agda-stdlib calls this Total, and we should too really.)
(Add in Decidable _==_, and I bet you can search.)

#+begin_src agda2
data SortedListHard (A : Type ℓ) : Type ℓ where
  -- h̷̢̘͙̳͙͇̥̐̓͌͌̈̾͜͠͝ȩ̸̡̨̳̭̘̹̞̩̠͉̥͍͔͂̆̏̆͂͗̀͊̒͊̄͋̄̕ͅ ̷͎̺̯͕̋̍̊c̵̢̨̜̬̦͎̪͔̩͕͔̪̊̏̈́̃̂̉͆̆̿͗͘̚͘͝ó̸̡̜̺̻̫m̶̧̨̩̘̻̯͍̜̥̥̪̩̮͔̎̓̈́̅͗͆̆e̶͉͚̙̫͇̩̻̩̯͂̉̂̈́͂̐̌͊͒̾̌̀̕̚͜ş̶̳̣̦͔͍͔̘͍͇̮͍̫̠͈͊

#+end_src


* Задача 4 (⋆⋆)
Покажите, что ~reNotEmpty re~ корректно /отражает/ ситуацию, в которой существует любая строка, матчащаяся
регуляркой ~re~.

#+begin_src agda2

reNotEmpty : {A : Type ℓ} → RegExp A → 𝔹
reNotEmpty ø = false
reNotEmpty ε = true
reNotEmpty (‵ _) = true
reNotEmpty (re₁ ∙ re₂) = reNotEmpty re₁ && reNotEmpty re₂
reNotEmpty (re₁ ∣ re₂) = reNotEmpty re₁ || reNotEmpty re₂
reNotEmpty (_ +) = true

reNE-correct : {A : Type ℓ} {s : List A} {re : RegExp A} →
               (s =~ re) → reNotEmpty re ≡ true
reNE-correct = {!!}

#+end_src

* Задача 5, [[https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages][лемма о накачке]] (⋆⋆⋆⋆⋆)
Если строка ~s~ матчится регуляркой, и длина строки больше, чем некоторая константа, то внутри ~s~ существует
суффикс, который можно невозобранно повторять, и результат тоже будет матчиться той же регуляркой.

#+begin_src agda2

pumpingConstant : {A : Type ℓ} → RegExp A → ℕ
pumpingConstant ø = 0
pumpingConstant ε = 1
pumpingConstant (‵ _) = 2
pumpingConstant (re₁ ∙ re₂) = pumpingConstant re₁ + pumpingConstant re₂
pumpingConstant (re₁ ∣ re₂) = pumpingConstant re₁ + pumpingConstant re₂
pumpingConstant (_ +) = 1

pump : {A : Type ℓ} → ℕ → List A → List A
pump 0       xs = xs
pump (suc n) xs = xs ++ pump n xs

pumpingLemma : {A : Type ℓ} {s : List A} {re : RegExp A} → (s =~ re) →
               (pumpingConstant re ≤ₙ length s) →
               Σ _ λ s₁ → Σ _ λ s₂ → Σ _ λ s₃ → (s ≡ s₁ ++ s₂ ++ s₃) × (¬ (s₂ ≡ [])) × ((m : ℕ) → s₁ ++ pump m s₂ ++ s₃ =~ re)
pumpingLemma = {!!}

#+end_src
