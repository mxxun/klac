#+begin_src agda2

{-# OPTIONS --guardedness #-}
module homework.Day4 where

open import Prelude
open import Day4

open import Data.Bool using (false; true) renaming (Bool to ùîπ; _‚àß_ to _&&_; _‚à®_ to _||_)
open import Data.List using (List; []; _‚à∑_; _++_; length)
open import Data.List.Membership.Propositional using (_‚àà_)
open import Data.List.Relation.Unary.All using (All)
open import Data.List.Relation.Unary.Any using (here; there)
open import Data.Nat using (‚Ñï; zero; suc; _+_) renaming (_‚â§_ to _‚â§‚Çô_)
open import Relation.Binary using (Rel; IsPartialOrder)
open import Relation.Nullary using (¬¨_; Reflects; yes; no)

#+end_src

* –ó–∞–¥–∞—á–∞ 1 (‚ãÜ‚ãÜ)
–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ –≤—ã –∑–Ω–∞–∫–æ–º—ã —Å –ø–æ–Ω—è—Ç–∏–µ–º /[[https://en.wikipedia.org/wiki/Partially_ordered_set][—á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞]]/. 
–û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ /–Ω–µ—É–±—ã–≤–∞—é—â–∏–µ (–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ) —Å–ø–∏—Å–∫–∏/.

#+begin_src agda2

record PartialOrder (A : Type ‚Ñì) : Type (suc-‚Ñì ‚Ñì) where
  field
    _‚â§_ : Rel A ‚Ñì
    ipo : IsPartialOrder _‚â°_ _‚â§_
open PartialOrder ‚¶É ... ‚¶Ñ

-- –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ —Å–ª–µ–¥—É—é—â–∏–µ –∑–∞ `t` —ç–ª–µ–º–µ–Ω—Ç—ã
nextElems : {A : Type ‚Ñì}
            {t : A} {xs : List A}
            (p : t ‚àà xs) ‚Üí List A
nextElems {xs = _ ‚à∑ xs‚Ä≤} (here  _) = xs‚Ä≤
nextElems {xs = _ ‚à∑ _  } (there p) = nextElems p

-- –Ω–∞–∏–≤–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏: —Å–ø–∏—Å–æ–∫ `xs` –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω, –µ—Å–ª–∏ –¥–ª—è –ª—é–±–æ–≥–æ
-- —ç–ª–µ–º–µ–Ω—Ç–∞ `t`, –ª–µ–∂–∞—â–µ–≥–æ –≤ `xs`, t –º–µ–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–µ–Ω –≤—Å–µ–º –ø–æ—Å–ª–µ–¥—É—é—â–∏–º —ç–ª–µ–º–µ–Ω—Ç–∞–º
is-sorted : {A : Type ‚Ñì}
            ‚¶É po : PartialOrder A ‚¶Ñ
            (xs : List A) ‚Üí Type ‚Ñì
is-sorted {_} {A} xs = {t : A} (p : t ‚àà xs) ‚Üí All (t ‚â§_) (nextElems p)

-- –¥–∞–≤–∞–π—Ç–µ —Å–¥–µ–ª–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ç–∏–ø, —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥—É—Ç _—Ç–æ–ª—å–∫–æ_ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏
SortedList : (A : Type ‚Ñì) ‚¶É po : PartialOrder A ‚¶Ñ ‚Üí Type ‚Ñì
SortedList A = Œ£ (List A) is-sorted

forget-naive : {A : Type ‚Ñì} ‚¶É po : PartialOrder A ‚¶Ñ ‚Üí
               SortedList A ‚Üí List A
forget-naive = fst

validate-naive : {A : Type ‚Ñì}
                 ‚¶É po : PartialOrder A ‚¶Ñ
                 (xs‚Çõ : SortedList A) ‚Üí is-sorted (forget-naive xs‚Çõ)
validate-naive = snd

#+end_src


* –ó–∞–¥–∞—á–∞ 2 (‚ãÜ‚ãÜ‚ãÜ‚ãÜ)
–¢–µ–ø–µ—Ä—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ —Å –ø–æ–º–æ—â—å—é –∏–Ω–¥—É–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–µ–¥–∏–∫–∞—Ç–∞.

#+begin_src agda2

data IsSorted {A : Type ‚Ñì} ‚¶É po : PartialOrder A ‚¶Ñ : List A ‚Üí Type ‚Ñì where
  -- –∫–∞–∫–∏–µ –µ—Å—Ç—å –ø—Ä–∏–Ω—Ü–∏–ø–∏–∞–ª—å–Ω–æ —Ä–∞–∑–Ω—ã–µ —Å–ª—É—á–∞–∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ —Å–ø–∏—Å–∫–æ–≤?
  nil  : IsSorted []
  sing : ‚àÄ a -> IsSorted (a ‚à∑ [])
  ext  : ‚àÄ a‚ÇÅ a‚ÇÇ as -> a‚ÇÅ ‚â§ a‚ÇÇ -> IsSorted (a‚ÇÇ ‚à∑ as) -> IsSorted (a‚ÇÅ ‚à∑ a‚ÇÇ ‚à∑ as)

SortedList·µ¢ : (A : Type ‚Ñì) ‚¶É po : PartialOrder A ‚¶Ñ ‚Üí Type ‚Ñì
SortedList·µ¢ A = Œ£ (List A) IsSorted

forget·µ¢ : {A : Type ‚Ñì} ‚¶É po : PartialOrder A ‚¶Ñ ‚Üí
          SortedList·µ¢ A ‚Üí List A
forget·µ¢ = fst


validate·µ¢ : {A : Type ‚Ñì}
            ‚¶É po : PartialOrder A ‚¶Ñ
            (xs‚Çõ : SortedList·µ¢ A) ‚Üí is-sorted (forget·µ¢ xs‚Çõ)
-- wait, where's the nil case?
validate·µ¢ (xs , sing a) {t} (here px) = All.[]
validate·µ¢ (.(a‚ÇÅ ‚à∑ a‚ÇÇ ‚à∑ as) , ext a‚ÇÅ a‚ÇÇ as a‚ÇÅ‚â§a‚ÇÇ ISa‚ÇÇ‚à∑as) {.a‚ÇÅ} (here refl) =
  a‚ÇÅ‚â§a‚ÇÇ All.‚à∑ All.map I (validate·µ¢ (a‚ÇÇ ‚à∑ as , ISa‚ÇÇ‚à∑as) (here refl))
  where
    open import Data.List.Relation.Unary.All as All
    I : ‚àÄ {a} -> a‚ÇÇ ‚â§ a -> a‚ÇÅ ‚â§ a
    I a‚ÇÇ‚â§a = IsPartialOrder.trans ipo a‚ÇÅ‚â§a‚ÇÇ a‚ÇÇ‚â§a
    -- II : All (a‚ÇÇ ‚â§_) as
    -- II = validate·µ¢ (a‚ÇÇ ‚à∑ as , ISa‚ÇÇ‚à∑as) (here refl)
validate·µ¢ (.(a‚ÇÅ ‚à∑ a‚ÇÇ ‚à∑ as) , ext a‚ÇÅ a‚ÇÇ as x snd‚ÇÅ) {t} (there p) =
  validate·µ¢ (a‚ÇÇ ‚à∑ as , snd‚ÇÅ) p

#+end_src


* –ó–∞–¥–∞—á–∞ 3 (‚ãÜ‚ãÜ‚ãÜ‚ãÜ‚ãÜ)
–ú–æ–∂–Ω–æ –ª–∏ –Ω–∞–ø—Ä—è–º—É—é –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ –∫–∞–∫ –∏–Ω–¥—É–∫—Ç–∏–≤–Ω—ã–π —Ç–∏–ø?
–î–ª—è –≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏—è –ø–æ—á–∏—Ç–∞–π—Ç–µ [[https://personal.cis.strath.ac.uk/conor.mcbride/Pivotal.pdf][How to keep your neighbours in order]].

A: 
See: Day4.SortedListHard.agda. it's fun!
....following the paper, we pose that the question is not whether we _can_; of course we can.
the real question is: how to define inherently-sorted lists so as to provide a convenient API?
e.g. : end-user programmers (including us) would rather....not prove anything they don't strictly need.
you'd be surprised how few things you _do_ need!
It turns out `Dichotomous _‚â§_` is enough to construct, insert, rotate, merge, append...
(----NB: agda-stdlib calls this Total, and we should too really.)
(Add in Decidable _==_, and I bet you can search.)

#+begin_src agda2
data SortedListHard (A : Type ‚Ñì) : Type ‚Ñì where
  -- hÃ∑ÃêÕ†ÃìÕåÕùÕåÃàÃæÃòÕôÃ≥ÕôÕáÃ•ÕúÃ¢eÃ∏ÕÇÃÜÃèÃÜÕÇÕóÃïÕÄÕäÃíÕäÃÑÕãÃÑÃßÃ≥Ã≠ÕÖÃòÃπÃûÃ©Ã†ÕâÃ•ÕçÃ°Ã®Õî Ã∑ÃãÃçÃäÕéÃ∫ÃØÕïcÃµÃäÃèÕòÕÑÃöÃÉÃÇÃâÕùÕÜÕòÃÜÃøÕóÃúÃ¨Ã¢Ã¶ÕéÃ®Ã™ÕîÃ©ÕïÕîÃ™oÃ∏ÕÅÃúÃ°Ã∫ÃªÃ´mÃ∂ÃéÕÉÕÑÃÖÕóÕÜÃÜÃ©ÃòÃªÃØÕçÃúÃ•ÃßÃ®Ã•Ã™Ã©ÃÆÕîeÃ∂ÕÇÃâÃÇÃïÕÑÃöÕÇÃêÃåÕäÕíÃæÃåÕÄÕâÕöÃôÃ´ÕáÃ©ÃªÕúÃ©ÃØsÃ∂ÕäÃ≥Ã£Ã¶ÕîÃßÕçÕîÃòÕçÕáÃÆÕçÃ´Ã†Õà

#+end_src


* –ó–∞–¥–∞—á–∞ 4 (‚ãÜ‚ãÜ)
–ü–æ–∫–∞–∂–∏—Ç–µ, —á—Ç–æ ~reNotEmpty re~ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ /–æ—Ç—Ä–∞–∂–∞–µ—Ç/ —Å–∏—Ç—É–∞—Ü–∏—é, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª—é–±–∞—è —Å—Ç—Ä–æ–∫–∞, –º–∞—Ç—á–∞—â–∞—è—Å—è
—Ä–µ–≥—É–ª—è—Ä–∫–æ–π ~re~.

#+begin_src agda2

reNotEmpty : {A : Type ‚Ñì} ‚Üí RegExp A ‚Üí ùîπ
reNotEmpty √∏ = false
reNotEmpty Œµ = true
reNotEmpty (‚Äµ _) = true
reNotEmpty (re‚ÇÅ ‚àô re‚ÇÇ) = reNotEmpty re‚ÇÅ && reNotEmpty re‚ÇÇ
reNotEmpty (re‚ÇÅ ‚à£ re‚ÇÇ) = reNotEmpty re‚ÇÅ || reNotEmpty re‚ÇÇ
reNotEmpty (re +) = reNotEmpty re

reNE-correct : {A : Type ‚Ñì} {s : List A} {re : RegExp A} ‚Üí
               (s =~ re) ‚Üí reNotEmpty re ‚â° true
reNE-correct MEmpty = refl
reNE-correct MChar = refl
reNE-correct {re = re‚ÇÅ ‚àô re‚ÇÇ} (MApp ml mr) with reNE-correct ml | reNE-correct mr
...| eql | eqr = trans (cong (\t -> t && reNotEmpty re‚ÇÇ) eql) eqr
reNE-correct {re = re‚ÇÅ ‚à£ re‚ÇÇ} (MUnionL m) with reNE-correct m
...| eq = cong (\t -> t || reNotEmpty re‚ÇÇ) eq
reNE-correct {re = re‚ÇÅ ‚à£ re‚ÇÇ} (MUnionR m) with reNE-correct m
...| eq = trans (cong (\t -> reNotEmpty re‚ÇÅ || t) eq) I
  where
    I : ‚àÄ {b} -> b || true ‚â° true
    I {false} = refl
    I {true} = refl
reNE-correct (MPlus0 m) = reNE-correct m
reNE-correct (MPlusS m m‚ÇÅ) = reNE-correct m

reNE-correct2 : {A : Type ‚Ñì} (re : RegExp A) ‚Üí
               reNotEmpty re ‚â° true ‚Üí Œ£[ s ‚àà List A ] (s =~ re)
reNE-correct2 Œµ eq = [] , MEmpty
reNE-correct2 (‚Äµ x) eq = x ‚à∑ [] , MChar
reNE-correct2 (reL ‚àô reR) eq with
  reNotEmpty reL in eqL | reNotEmpty reR in eqR
...| true | true with reNE-correct2 reL eqL | reNE-correct2 reR eqR
...  | sL , prfL | sR , prfR = sL ++ sR , MApp prfL prfR
reNE-correct2 (reL ‚à£ reR) eq with reNotEmpty reL in eqL
... | false with reNE-correct2 reR eq
...   | s , prf = s , MUnionR prf
reNE-correct2 (reL ‚à£ reR) eq
    | true with reNE-correct2 reL eqL
...   | s , prf = s , MUnionL prf
reNE-correct2 (re +) eq with reNE-correct2 re eq
...| s , prf = s , MPlus0 prf
-- yeah so that's fun.


-- Uh no it's not?
-- √∏+-empty : ‚àÄ {A W : Type ‚Ñì} {s : List A} -> (s =~ (√∏ +)) -> W
-- √∏+-empty (MPlus0 ())
-- √∏+-empty (MPlusS () m‚ÇÅ)

#+end_src

* –ó–∞–¥–∞—á–∞ 5, [[https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages][–ª–µ–º–º–∞ –æ –Ω–∞–∫–∞—á–∫–µ]] (‚ãÜ‚ãÜ‚ãÜ‚ãÜ‚ãÜ)
–ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ ~s~ –º–∞—Ç—á–∏—Ç—Å—è —Ä–µ–≥—É–ª—è—Ä–∫–æ–π, –∏ –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏ –±–æ–ª—å—à–µ, —á–µ–º –Ω–µ–∫–æ—Ç–æ—Ä–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞, —Ç–æ –≤–Ω—É—Ç—Ä–∏ ~s~ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
—Å—É—Ñ—Ñ–∏–∫—Å, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –Ω–µ–≤–æ–∑–æ–±—Ä–∞–Ω–Ω–æ –ø–æ–≤—Ç–æ—Ä—è—Ç—å, –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–æ–∂–µ –±—É–¥–µ—Ç –º–∞—Ç—á–∏—Ç—å—Å—è —Ç–æ–π –∂–µ —Ä–µ–≥—É–ª—è—Ä–∫–æ–π.

#+begin_src agda2

pumpingConstant : {A : Type ‚Ñì} ‚Üí RegExp A ‚Üí ‚Ñï
pumpingConstant √∏ = 0
pumpingConstant Œµ = 1
pumpingConstant (‚Äµ _) = 2
pumpingConstant (re‚ÇÅ ‚àô re‚ÇÇ) = pumpingConstant re‚ÇÅ + pumpingConstant re‚ÇÇ
pumpingConstant (re‚ÇÅ ‚à£ re‚ÇÇ) = pumpingConstant re‚ÇÅ + pumpingConstant re‚ÇÇ -- I think this could be max
pumpingConstant (_ +) = 1

pump : {A : Type ‚Ñì} ‚Üí ‚Ñï ‚Üí List A ‚Üí List A
pump 0       xs = xs
pump (suc n) xs = xs ++ pump n xs

-- I : ‚àÄ s -> 1 ‚â§‚Çô length s -> ¬¨ s ‚â° []
-- I s prf = {!!}

pump-+ : {A : Type ‚Ñì} (s : List A) (re : RegExp A) -> s =~ re -> ‚àÄ n -> pump n s =~ re +
pump-+ s re match zero = MPlus0 match
pump-+ s re match (suc n) = MPlusS match (pump-+ s re match n)

+-++ : ‚àÄ {A : Type ‚Ñì} sL sR (re : RegExp A) -> sL =~ re + -> sR =~ re + -> sL ++ sR =~ re +
+-++ sL sR re (MPlus0 mL) = MPlusS mL
+-++ s sR re (MPlusS {s‚ÇÅ = sL} {s‚ÇÇ = sM} mL mM) = Œª mR ‚Üí
  subst (\t -> t =~ re +) (sym (++-assoc sL sM sR)) (MPlusS mL (+-++ sM sR re mM mR)) where
  open import Data.List.Properties

open import Data.Sum using (_‚äé_)
+‚â§‚Çô+-‚â§‚Çô‚äé‚â§‚Çô : ‚àÄ a b c d -> a + b ‚â§‚Çô c + d -> a ‚â§‚Çô c ‚äé b ‚â§‚Çô d
+‚â§‚Çô+-‚â§‚Çô‚äé‚â§‚Çô a b c d = {!!} -- can we.....not.
-- ...ok, sketch: Decide on a‚â§c and b‚â§d. if either, great; if both don't, combine into a+b > c+d.
-- from there...uh either directly contradiction, or again Decide on a+b‚â§c+d and from there definitely contradition in both cases.

++-ass3 : ‚àÄ {A : Type ‚Ñì} (a : List A) b c d -> (a ++ b ++ c) ++ d ‚â° a ++ b ++ c ++ d
++-ass3 a b c d = begin
  (a ++ b ++ c) ++ d ‚â°‚ü® ++-assoc a (b ++ c) d ‚ü©
  a ++ (b ++ c) ++ d ‚â°‚ü® cong (a ++_) (++-assoc b c d) ‚ü©
  a ++ b ++ c ++ d ‚àé
  where open ‚â°-Reasoning; open import Data.List.Properties
++-ass3' : ‚àÄ {A : Type ‚Ñì} (a : List A) b c d -> a ++ b ++ c ++ d ‚â° (a ++ b) ++ c ++ d
++-ass3' a b c d = sym (++-assoc a b (c ++ d))
  where open import Data.List.Properties
aux‚àô : ‚àÄ {A : Type ‚Ñì} a b (sL : List A) sR -> a + b ‚â§‚Çô length (sL ++ sR) -> a ‚â§‚Çô length sL ‚äé b ‚â§‚Çô length sR
aux‚àô a b sL sR prf = +‚â§‚Çô+-‚â§‚Çô‚äé‚â§‚Çô _ _ _ _ (subst (\t -> a + b ‚â§‚Çô t) (length-++ sL) prf)
  where open import Data.List.Properties


pumpingLemma : {A : Type ‚Ñì} {s : List A} {re : RegExp A} ‚Üí (s =~ re) ‚Üí
               (pumpingConstant re ‚â§‚Çô length s) ‚Üí
               Œ£[ s‚ÇÅ ‚àà _ ] Œ£[ s‚ÇÇ ‚àà _ ] Œ£[ s‚ÇÉ ‚àà _ ]
               (s ‚â° s‚ÇÅ ++ s‚ÇÇ ++ s‚ÇÉ) √ó (¬¨ (s‚ÇÇ ‚â° [])) √ó ((m : ‚Ñï) ‚Üí s‚ÇÅ ++ pump m s‚ÇÇ ++ s‚ÇÉ =~ re)
pumpingLemma {re = Œµ} MEmpty ()
pumpingLemma {re = ‚Äµ x} MChar (_‚â§‚Çô_.s‚â§s ())
pumpingLemma {re = reL ‚àô reR} (MApp {s‚ÇÅ = sL} {s‚ÇÇ = sR} mL mR) long with aux‚àô _ _ sL sR long
... | _‚äé_.inj‚ÇÅ x with pumpingLemma mL x
... | sL' , sP , sM , splits , sPNE , pumps =
      sL' , sP , sM ++ sR , I , sPNE , II
  where
  I :  sL ++ sR ‚â° sL' ++ sP ++ sM ++ sR
  I = trans (cong (_++ sR) splits) (++-ass3 sL' sP sM sR)
  
  II : (m : ‚Ñï) ‚Üí sL' ++ pump m sP ++ sM ++ sR =~ reL ‚àô reR
  II m = subst (\t -> t =~ reL ‚àô reR) III (MApp (pumps m) mR)
    where
    III : (sL' ++ pump m sP ++ sM) ++ sR ‚â° sL' ++ pump m sP ++ sM ++ sR
    III = ++-ass3 sL' (pump m sP) sM sR
pumpingLemma {re = reL ‚àô reR} (MApp {s‚ÇÅ = sL} {s‚ÇÇ = sR} mL mR) long
    | _‚äé_.inj‚ÇÇ y with pumpingLemma mR y
... | sM , sP , sR' , splits , sPNE , pumps =
      sL ++ sM , sP , sR' , I , sPNE , II
  where
  I : sL ++ sR ‚â° (sL ++ sM) ++ sP ++ sR'
  I = trans (cong (sL ++_) splits) (++-ass3' sL sM sP sR')
  II : (m : ‚Ñï) ‚Üí (sL ++ sM) ++ pump m sP ++ sR' =~ reL ‚àô reR
  II m = subst (\t -> t =~ reL ‚àô reR) III (MApp mL (pumps m))
    where
    III : sL ++ sM ++ pump m sP ++ sR' ‚â° (sL ++ sM) ++ pump m sP ++ sR'
    III = ++-ass3' sL sM (pump m sP) sR'
pumpingLemma {re = reL ‚à£ reR} (MUnionL m) long -- recurse w/ transitivity of pC reL <= + <= length
  with pumpingLemma m (m+n‚â§o‚áím‚â§o (pumpingConstant reL) long)
  where open import Data.Nat.Properties
...| sL , sP , sR , splits , sPNE , pumps =
     sL , sP , sR , splits , sPNE , Œª m ‚Üí MUnionL (pumps m)
pumpingLemma {re = reL ‚à£ reR} (MUnionR m) long
  with pumpingLemma m (m+n‚â§o‚áín‚â§o (pumpingConstant reL) long)
  where open import Data.Nat.Properties
...| sL , sP , sR , splits , sPNE , pumps =
     sL , sP , sR , splits , sPNE , Œª m ‚Üí MUnionR (pumps m)
pumpingLemma {s = s} {re = re +} (MPlus0 match) long =
  [] , s , [] , sym (++-identity ≥ s) , I s long , III where
  open import Data.List.Properties
  I : ‚àÄ s -> 1 ‚â§‚Çô length s -> ¬¨ s ‚â° []
  I .[] () refl
  III : (m : ‚Ñï) -> pump m s ++ [] =~ re +
  III m = subst (\t -> t =~ re +) (sym (++-identity ≥ _)) (pump-+ s re match m )
pumpingLemma {re = re +} (MPlusS {s‚ÇÅ = []} {s‚ÇÇ = sRest} m mRest) long =
  pumpingLemma mRest long
pumpingLemma {re = re +} (MPlusS {s‚ÇÅ = x ‚à∑ sFst} {s‚ÇÇ = sRest} mFst mRest) long =
  [] , x ‚à∑ sFst , sRest , refl , I , II where
  I : ¬¨ x ‚à∑ sFst ‚â° []
  I ()
  II : (n : ‚Ñï) ‚Üí pump n (x ‚à∑ sFst) ++ sRest =~ re +
  II n = +-++ _ sRest re (pump-+ (x ‚à∑ sFst) re mFst n ) mRest

#+end_src
