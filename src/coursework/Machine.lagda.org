* virtual machine time

#+begin_src agda2

{-# OPTIONS --safe #-}
module coursework.Machine where

open import Data.Nat using (‚Ñï; zero; suc; NonZero; _‚â§_; _‚â§·µá_; s‚â§s; _*_) renaming (pred to pred‚Çô)
open import Data.Nat.Properties using (‚â§·µá‚áí‚â§; _‚â§?_) renaming (_‚âü_ to _‚âü‚Çô_)
open import Data.Bool using (T) renaming (Bool to ùîπ; false to f‚Ä≤; true to t‚Ä≤)
open import Data.Bool.Properties using () renaming (_‚âü_ to _‚âü·µá_)
open import Data.Fin.Base using (Fin; zero; suc; pred; to‚Ñï)
open import Data.Maybe using (Maybe; nothing; just; _>>=_)
open import Function.Base using (_$_; _‚àò_; _‚àò‚Ä≤_)
open import Relation.Nullary using (¬¨_; Dec; yes; no; contradiction)
open import Relation.Nullary.Decidable using (‚åä_‚åã)
open import Function.Inverse using (_‚Üî_; Inverse)
open import Data.Empty using (‚ä•)
open import Function.Equality using (_‚ü®$‚ü©_)
open Inverse

open import Generics

open import Prelude
open import coursework.Bits
open Serializable

#+end_src

* –†–µ–≥–∏—Å—Ç—Ä —Ñ–ª–∞–≥–æ–≤
** –ï—Å–ª–∏ —Ñ–ª–∞–≥ ~stop~ –ø–æ–¥–Ω—è—Ç, —Ç–æ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç—Å—è
** ~overflow~ –≤–∑–≤–æ–¥–∏—Ç—Å—è –ø—Ä–∏ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–∏ –≤ –æ–ø–µ—Ä–∞—Ü–∏—è—Ö —Å–ª–æ–∂–µ–Ω–∏—è –∏ —É–º–Ω–æ–∂–µ–Ω–∏—è
   –ø–æ–∫–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

#+begin_src agda2

record Flags : Type‚ÇÄ where
  constructor mkFlags
  field
    stop     : Bit
    overflow : Bit
open Flags

instance
  decEqFlags : DecEq Flags
  DecEq._‚âü_ decEqFlags x y with stop x ‚âü stop y
  ... | no ¬¨f = no Œª p ‚Üí ¬¨f (cong stop p)
  ... | yes f with overflow x ‚âü overflow y
  ... | no ¬¨o = no Œª p ‚Üí ¬¨o (cong overflow p)
  ... | yes o = yes (cong‚ÇÇ mkFlags f o)

initFlags : Flags
initFlags = record
  { stop     = 0b
  ; overflow = 0b
  }

stop·∂† : Flags ‚Üí Flags
stop·∂† f = record f { stop = 1b }

#+end_src

* –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
–í–º–µ—Å—Ç–æ –ø—Ä–∏–≤—ã—á–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã —Ñ–æ–Ω –ù–µ–π–º–∞–Ω–∞ –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ì–∞—Ä–≤–∞—Ä–¥—Å–∫—É—é.
–î–ª—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –µ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ–µ read-only —Ö—Ä–∞–Ω–∏–ª–∏—â–µ ~program~, instruction pointer ~ip~
—É–∫–∞–∑—ã–≤–∞–µ—Ç –∫—É–¥–∞-—Ç–æ –≤–Ω—É—Ç—Ä—å —ç—Ç–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞, –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –Ω–∞ –Ω—É–ª–µ–≤–æ–π –±–∞–π—Ç.
–î–ª—è –¥–∞–Ω–Ω—ã—Ö –µ—Å—Ç—å —Å—Ç–µ–∫.

–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –µ–¥–∏–Ω–∏—Ü–∞ –∞–¥—Ä–µ—Å–∞—Ü–∏–∏ ‚Äî 1 –±–∞–π—Ç.
–†–∞–∑–º–µ—Ä –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–Ω–æ–≥–æ —Å–ª–æ–≤–∞ ‚Äî 2 –±–∞–π—Ç–∞.

#+begin_src agda2

record MS (programSize : ‚Ñï) (program : ByteArray programSize) : Type‚ÇÄ where
  constructor mkMS
  field
    ip        : BytePtr programSize
    flags     : Flags
    stackSize : ‚Ñï
    stack     : ByteArray stackSize
open MS

initMachine : (ps : ‚Ñï) ‚¶É _ : NonZero ps ‚¶Ñ
              (p : ByteArray ps) (ss : ‚Ñï) ‚Üí
              MS ps p
initMachine (suc ps) p ss = record
  { ip = zero
  ; flags = initFlags
  ; stackSize = ss
  ; stack = memset 0byte
  }

private
  variable
    ps ps‚Ä≤ ss : ‚Ñï
    p : ByteArray ps

-- it wraps around
nextIp‚Ä≤ : BytePtr (suc ps) ‚Üí BytePtr (suc ps)
nextIp‚Ä≤ {ps} ip with to‚Ñï ip ‚âü‚Çô ps
... | yes _ = zero
... | no  p with helper ip p
  where
  helper : {ps : ‚Ñï} ‚Üí (ip : BytePtr (suc ps)) ‚Üí (to‚Ñï ip ‚â¢ ps) ‚Üí Œ£ ‚Ñï Œª ps‚Ä≤ ‚Üí ps ‚â° suc ps‚Ä≤
  helper {zero        } zero       p = contradiction refl p
  helper {suc zero    } zero       _ = zero , refl
  helper {suc zero    } (suc zero) p = contradiction refl p
  helper {suc (suc ps)} _          _ = suc ps , refl
... | ps‚Ä≤ , refl with ip
... | zero    = suc zero
... | suc ip‚Ä≤ = suc (nextIp‚Ä≤ ip‚Ä≤)

iterate : ‚Ñï ‚Üí (A ‚Üí A) ‚Üí (A ‚Üí A)
iterate 0       _ x = x
iterate (suc n) f x = iterate n f (f x)

nextIp : BytePtr (suc ps) ‚Üí BytePtr (suc ps)
nextIp = iterate 2 nextIp‚Ä≤

#+end_src

* Instruction set

#+begin_src agda2

data Instr : Type‚ÇÄ where
  push         :     Byte ‚Üí Instr
  pop          :            Instr
  add          :            Instr
-- sub mul  :            Instr
  eq           :            Instr
--  neq le gt :            Instr
--   skip         :     Byte ‚Üí Instr
  skipIf       : ùîπ ‚Üí Byte ‚Üí Instr
  nop halt     :            Instr

InstrD : HasDesc Instr
InstrD = deriveDesc Instr

instance
  showInstr : Show Instr
  showInstr = deriveShow InstrD

bitsAndBytes : Bits 16 ‚Üî ByteArray 2
to bitsAndBytes = record
  { _‚ü®$‚ü©_ = Œª where
      (b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ bs) ‚Üí (b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ []) ‚à∑ bs ‚à∑ []
  ; cong = Œª { refl ‚Üí refl }
  }
from bitsAndBytes = record
  { _‚ü®$‚ü©_ = Œª where
      (x ‚à∑ y ‚à∑ []) ‚Üí x ++ y
  ; cong = Œª { refl ‚Üí refl }
  }
inverse-of bitsAndBytes = record
  { left-inverse-of = Œª where
      (b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ bs) ‚Üí refl
  ; right-inverse-of = Œª where
      ((b‚ÇÄ ‚à∑ b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ b‚ÇÉ ‚à∑ b‚ÇÑ ‚à∑ b‚ÇÖ ‚à∑ b‚ÇÜ ‚à∑ b‚Çá ‚à∑ []) ‚à∑ bs ‚à∑ []) ‚Üí refl
  }
  
serInstr : Serializable Instr 2
serInstr = record { encode = encode‚Ä≤ ; decode = decode‚Ä≤ ; decode‚àòencode = inverses‚ÇÅ ; encode‚àòdecode = inverses‚ÇÇ }
  where
  encode‚Ä≤ : Instr ‚Üí ByteArray 2
  encode‚Ä≤ halt          = 0byte                                        ‚à∑ 0byte ‚à∑ []
  encode‚Ä≤ nop           = (0b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ (skip b)      = (0b ‚à∑ 0b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ (skipIf f‚Ä≤ b) = (0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ (skipIf t‚Ä≤ b) = (0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ (push b)      = (0b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ b     ‚à∑ []
  encode‚Ä≤ pop           = (0b ‚à∑ 1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
  encode‚Ä≤ add           = (1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ sub           = (1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
  encode‚Ä≤ eq            = (1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ mul           = (1b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ neq           = (1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ le            = (1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []
--   encode‚Ä≤ gt            = (1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ 0byte ‚à∑ []

  decode‚Ä≤ : ByteArray 2 ‚Üí Maybe Instr
  decode‚Ä≤ (0byte‚Çö                                               ‚à∑ 0byte‚Çö ‚à∑ []) = just halt
  decode‚Ä≤ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just nop
--   decode‚Ä≤ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (skip b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (skipIf f‚Ä≤ b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (skipIf t‚Ä≤ b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ b      ‚à∑ []) = just (push b)
  decode‚Ä≤ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just pop
  decode‚Ä≤ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just add
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just sub
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just mul
  decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just eq
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just neq
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just le
--   decode‚Ä≤ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) = just gt
  decode‚Ä≤ _ = nothing
  
  inverses‚ÇÅ : (i : Instr) ‚Üí decode‚Ä≤ (encode‚Ä≤ i) ‚â° just i
  inverses‚ÇÅ (push x) = refl
  inverses‚ÇÅ pop = refl
  inverses‚ÇÅ add = refl
--   inverses‚ÇÅ sub = refl
--   inverses‚ÇÅ mul = refl
  inverses‚ÇÅ eq = refl
--   inverses‚ÇÅ neq = refl
--   inverses‚ÇÅ le = refl
--   inverses‚ÇÅ gt = refl
--   inverses‚ÇÅ (skip _) = refl
  inverses‚ÇÅ (skipIf f‚Ä≤ _) = refl
  inverses‚ÇÅ (skipIf t‚Ä≤ _) = refl
  inverses‚ÇÅ nop = refl
  inverses‚ÇÅ halt = refl

  inverses‚ÇÇ : (ba : ByteArray 2) {i : Instr} ‚Üí decode‚Ä≤ ba ‚â° just i ‚Üí ba ‚â° encode‚Ä≤ i
  inverses‚ÇÇ (0byte‚Çö                                               ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
  inverses‚ÇÇ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = refl
  inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = refl
  inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = refl
  inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ _      ‚à∑ []) refl = refl
  inverses‚ÇÇ ((0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
  inverses‚ÇÇ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
  inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl
--   inverses‚ÇÇ ((1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ 0byte‚Çö ‚à∑ []) refl = refl

instance
  serBool : Serializable ùîπ 1
  serBool = record
    { encode = Œª where
        f‚Ä≤ ‚Üí 0byte ‚à∑ []
        t‚Ä≤ ‚Üí (1b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ 0b ‚à∑ []) ‚à∑ []
    ; decode = Œª where
        (0byte‚Çö ‚à∑ []                                              ) ‚Üí just f‚Ä≤
        ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ []) ‚Üí just t‚Ä≤
        _                                                           ‚Üí nothing
    ; decode‚àòencode = Œª where
        f‚Ä≤ ‚Üí refl
        t‚Ä≤ ‚Üí refl
    ; encode‚àòdecode = Œª where
        (0byte‚Çö ‚à∑ []) refl ‚Üí refl
        ((1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []) ‚à∑ []) refl ‚Üí refl
    }

decodeAs‚Ñï : Byte ‚Üí ‚Ñï
decodeAs‚Ñï = fromDigits ‚àò‚Ä≤ toList

#+end_src

* –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥
** fetch command at ip
** if it's invalid stop
** if it's valid then execute it and advance ip

#+begin_src agda2

private
  instance
    ‚â§-dec : {p : T (m ‚â§·µá n)} ‚Üí m ‚â§ n
    ‚â§-dec {p = p} = ‚â§·µá‚áí‚â§ _ _ p

fetch : MS ps p ‚Üí Maybe (ByteArray 2)
fetch {ps = suc (suc ps)} {p = p} ms with to‚Ñï (ip ms) ‚â§? ps
... | yes q = just $ slice_at_as_ p (ip ms) 2 ‚¶É s‚â§s (s‚â§s q) ‚¶Ñ
... | no  _ = nothing
fetch {ps = _           } _ = nothing

stop·µê : MS ps p ‚Üí MS ps p
stop·µê ms = record ms { flags = stop·∂† $ ms .flags }

execute : MS (suc ps) p ‚Üí Instr ‚Üí MS (suc ps) p
execute ms (push b) = record ms { ip = nextIp (ip ms) ; stackSize = suc (stackSize ms) ; stack = b ‚à∑ stack ms }
execute ms pop with stackSize ms in sEq
... | suc ss = record ms { ip = nextIp (ip ms) ; stackSize = ss ; stack = tail (subst ByteArray sEq (stack ms)) }
... | 0      = stop·µê ms
execute ms add with stackSize ms in sEq
... | 0            = stop·µê ms
... | 1            = stop·µê ms
... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ [] = let carry , res = b‚ÇÅ + b‚ÇÇ
                     in record ms { ip = nextIp (ip ms) ; flags = record { stop = stop (flags ms) ; overflow = carry } ; stackSize = suc ss ; stack = res ‚à∑ drop 2 (subst ByteArray sEq (stack ms)) }
execute ms eq with stackSize ms in sEq
... | 0 = stop·µê ms
... | 1 = stop·µê ms
... | suc (suc ss) with slice (subst ByteArray sEq (stack ms)) at zero as 2
... | b‚ÇÅ ‚à∑ b‚ÇÇ ‚à∑ [] with ‚åä b‚ÇÅ ‚âü b‚ÇÇ ‚åã
... | d = record ms { ip = nextIp (ip ms) ; stackSize = suc ss ; stack = single (encode serBool d) ‚à∑ drop 2 (subst ByteArray sEq (stack ms)) }
execute ms (skipIf c n) with stackSize ms in sEq
... | 0      = stop·µê ms
... | suc ss with decode serBool (take 1 (subst ByteArray sEq (stack ms)))
... | nothing = stop·µê ms
... | just c‚Ä≤ with ‚åä c ‚âü·µá c‚Ä≤ ‚åã
... | t‚Ä≤ = record ms { ip = iterate (decodeAs‚Ñï n) nextIp‚Ä≤ (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
... | f‚Ä≤ = record ms { ip = nextIp (ip ms) ; stackSize = ss; stack = tail (subst ByteArray sEq (stack ms))}
execute ms nop = record ms { ip = nextIp (ip ms) }
execute ms halt = stop·µê ms

-- fetch instruction, decode, execute
step : MS (suc ps) p ‚Üí MS (suc ps) p
step ms with stop (flags ms)
... | 1b‚Çö = ms
... | 0b‚Çö with fetch ms >>= decode serInstr
... | nothing = stop·µê ms
... | just i  = execute ms i

record _‚âà_ (x y : MS (suc ps) p) : Type‚ÇÄ where
  coinductive
  field
    sameFlags     : flags x ‚â° flags y
    sameStackSize : stackSize x ‚â° stackSize y
    sameStack     : subst ByteArray sameStackSize (stack x) ‚â° stack y
    sameCont      : step x ‚âà step y

MachineExtensionality : Type‚ÇÄ
MachineExtensionality = ‚àÄ {ps p} ‚Üí {x y : MS (suc ps) p} ‚Üí x ‚âà y ‚Üí x ‚â° y

assemble : Vec Instr n ‚Üí ByteArray (n * 2)
assemble []       = []
assemble (i ‚à∑ is) = encode serInstr i ++ assemble is

run_for_steps : MS (suc ps) p ‚Üí ‚Ñï ‚Üí MS (suc ps) p
run ms for 0     steps = ms
run ms for suc n steps = run (step ms) for n steps

Halts : MS (suc ps) p ‚Üí Type‚ÇÄ
Halts ms = Œ£ ‚Ñï Œª n ‚Üí stop (flags (run ms for n steps)) ‚â° 1b

module Test {machine-ext : MachineExtensionality} where

  trivial : MS _ _
  trivial = initMachine _ (assemble $ push 1byte ‚à∑ push 1byte ‚à∑ add ‚à∑ halt ‚à∑ []) 0

  trivial-halts : Halts trivial
  trivial-halts = 4 , refl

  loopyBoy : Vec Instr _
  loopyBoy = push 0byte ‚à∑ push 0byte ‚à∑ add ‚à∑ skipIf f‚Ä≤ (0b ‚à∑ 1b ‚à∑ replicate 0b) ‚à∑ []

  k : MS 8 _
  k = initMachine _ (assemble loopyBoy) 0

  k-loops : k ‚âà (run k for 4 steps)
  _‚âà_.sameFlags k-loops = refl
  _‚âà_.sameStackSize k-loops = refl
  _‚âà_.sameStack k-loops = refl
  _‚âà_.sameFlags (_‚âà_.sameCont k-loops) = refl
  _‚âà_.sameStackSize (_‚âà_.sameCont k-loops) = refl
  _‚âà_.sameStack (_‚âà_.sameCont k-loops) = refl
  _‚âà_.sameFlags (_‚âà_.sameCont (_‚âà_.sameCont k-loops)) = refl
  _‚âà_.sameStackSize (_‚âà_.sameCont (_‚âà_.sameCont k-loops)) = refl
  _‚âà_.sameStack (_‚âà_.sameCont (_‚âà_.sameCont k-loops)) = refl
  _‚âà_.sameFlags (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = refl
  _‚âà_.sameStackSize (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = refl
  _‚âà_.sameStack (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = refl
  _‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont (_‚âà_.sameCont k-loops))) = k-loops

  some-programs-do-not-halt : ¬¨ Halts k
  some-programs-do-not-halt (n , prf) = helper n prf
    where
    helper : (n : ‚Ñï) ‚Üí stop (flags (run k for n steps)) ‚â° 1b ‚Üí ‚ä•
    helper (suc (suc (suc (suc n)))) prf =
      helper n $ subst (Œª j ‚Üí stop (flags (run j for n steps)) ‚â° 1b) (sym $ machine-ext k-loops) prf

#+end_src
