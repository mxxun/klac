#+begin_src agda2

{-# OPTIONS --safe #-}
module coursework.Bits where

open import Prelude

open import Data.Bool using (false; true; T) renaming (Bool to ùîπ)
open import Data.Digit using (Bit; 0b; 1b; fromDigits; toDigits)
  public
open import Data.Fin using (Fin; zero; suc; to‚Ñï) renaming (_‚âü_ to _‚âü·∂†_)
open import Data.List using (List; []; _‚à∑_)
open import Data.Fin.Show using () renaming (show to showFin‚Ä≤)
open import Data.Nat using (‚Ñï; zero; suc; _‚à∏_; _‚â•_; _‚â§·µá_; _‚â§_; z‚â§n; s‚â§s; NonZero)
  renaming (_+_ to _+Ãá_; _‚âü_ to _‚âü‚Åø_)
open import Data.Nat.Properties using (‚â§·µá‚áí‚â§; ‚â§‚áí‚â§·µá; +-comm; +-assoc; m‚à∏n+n‚â°m)
open import Data.Nat.Show using () renaming (show to show‚Ñï)
open import Function.Base using (const)
open import Data.Maybe using (Maybe; just)

open import Generics

#+end_src

* Level-monomorphic vectors
–£–∂–∞—Å–Ω—ã–π –∫–æ—Å—Ç—ã–ª—å, –ø–æ–∫–∞ –±–µ–∑ –Ω–µ–≥–æ –Ω–µ –æ–±–æ–π—Ç–∏—Å—å. –í –±–∏–±–ª–∏–æ—Ç–µ–∫–µ generics –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å–¥–µ–ª–∞–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–ø–∏—Å–∞–Ω–∏–π
–¥–ª—è –ª–µ–≤–µ–ª–ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã—Ö —Ç–∏–ø–æ–≤. –£ –Ω–∞—Å —Ç—É—Ç –≤—Å—ë –≤–ø–æ–ª–Ω–µ –º–æ–∂–µ—Ç –∂–∏—Ç—å –Ω–∞ —Å–∞–º–æ–º –Ω–∏–∂–Ω–µ–º —É—Ä–æ–≤–Ω–µ, –ø–æ–∫–∞ —Å–æ–π–¥—ë—Ç.

#+begin_src agda2
module Vec‚Ä≤ where

  infixr 5 _‚à∑_
  
  data Vec (A : Type‚ÇÄ) : ‚Ñï ‚Üí Type‚ÇÄ where
    []  : Vec A zero
    _‚à∑_ : {n : ‚Ñï} (x : A) (xs : Vec A n) ‚Üí Vec A (suc n)

  VecD : HasDesc Vec
  VecD = deriveDesc Vec

  variable
    A B C : Type‚ÇÄ
    m n   : ‚Ñï

  instance
    showBool : Show ùîπ
    Show.show showBool false = "false"
    Show.show showBool true = "true"

    showNat : Show ‚Ñï
    Show.show showNat = show‚Ñï

    decEqNat : DecEq ‚Ñï
    DecEq._‚âü_ decEqNat = _‚âü‚Åø_

    showFin : Show (Fin n)
    Show.show showFin = showFin‚Ä≤

    decEqFin : DecEq (Fin n)
    DecEq._‚âü_ decEqFin = _‚âü·∂†_

    showVec : ‚¶É Show A ‚¶Ñ ‚Üí Show (Vec A n)
    showVec = deriveShow VecD
 
    decEqVec : ‚¶É DecEq A ‚¶Ñ ‚Üí DecEq (Vec A n)
    decEqVec = deriveDecEq VecD

  tail : Vec A (suc n) ‚Üí Vec A n
  tail (_ ‚à∑ xs) = xs

  lookup : Vec A n ‚Üí Fin n ‚Üí A
  lookup (x ‚à∑ _ ) zero = x
  lookup (_ ‚à∑ xs) (suc i) = lookup xs i

  replicate : A ‚Üí Vec A n
  replicate {n = zero}  x = []
  replicate {n = suc n} x = x ‚à∑ replicate x

  _++_ : Vec A m ‚Üí Vec A n ‚Üí Vec A (m +Ãá n)
  []       ++ ys = ys
  (x ‚à∑ xs) ++ ys = x ‚à∑ (xs ++ ys)

  splitAt : (m : ‚Ñï) {n : ‚Ñï} (xs : Vec A (m +Ãá n)) ‚Üí
            ‚àÉ‚ÇÇ Œª (ys : Vec A m) (zs : Vec A n) ‚Üí xs ‚â° ys ++ zs
  splitAt zero    xs                = ([] , xs , refl)
  splitAt (suc m) (x ‚à∑ xs)          with splitAt m xs
  splitAt (suc m) (x ‚à∑ .(ys ++ zs)) | (ys , zs , refl) =
    ((x ‚à∑ ys) , zs , refl)

  drop : (m : ‚Ñï) {n : ‚Ñï} ‚Üí Vec A (m +Ãá n) ‚Üí Vec A n
  drop m xs          with splitAt m xs
  drop m .(ys ++ zs) | (ys , zs , refl) = zs

  take : (m : ‚Ñï) {n : ‚Ñï} ‚Üí Vec A (m +Ãá n) ‚Üí Vec A m
  take m xs          with splitAt m xs
  take m .(ys ++ zs) | (ys , zs , refl) = ys

  zipWith : (A ‚Üí B ‚Üí C) ‚Üí Vec A n ‚Üí Vec B n ‚Üí Vec C n
  zipWith _ [] [] = []
  zipWith f (x ‚à∑ xs) (y ‚à∑ ys) = f x y ‚à∑ zipWith f xs ys

  toList : Vec A n ‚Üí List A
  toList []       = []
  toList (x ‚à∑ xs) = x ‚à∑ toList xs

  fromList : List A ‚Üí Œ£ ‚Ñï (Vec A)
  fromList []       = 0 , []
  fromList (x ‚à∑ xs) = let n , xs‚Ä≤ = fromList xs in suc n , x ‚à∑ xs‚Ä≤

open Vec‚Ä≤ public

Bits : ‚Ñï ‚Üí Type‚ÇÄ
Bits = Vec Bit

pattern 0b‚Çö = zero
pattern 1b‚Çö = suc zero

Byte : Type‚ÇÄ
Byte = Bits 8

0byte : Byte
0byte = replicate 0b
pattern 0byte‚Çö = 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []

1byte : Byte
1byte = 1b ‚à∑ replicate 0b
pattern 1byte‚Çö = 1b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ 0b‚Çö ‚à∑ []

or·µá : Bit ‚Üí Bit ‚Üí Bit
or·µá 0b‚Çö x = x
or·µá 1b‚Çö _ = 1b

_||_ : Bits n ‚Üí Bits n ‚Üí Bits n
_||_ = zipWith or·µá

and·µá : Bit ‚Üí Bit ‚Üí Bit
and·µá 0b‚Çö _ = 0b
and·µá 1b‚Çö x = x

_&&_ : Bits n ‚Üí Bits n ‚Üí Bits n
_&&_ = zipWith and·µá

xor·µá : Bit ‚Üí Bit ‚Üí Bit
xor·µá 0b‚Çö 0b‚Çö = 1b
xor·µá 0b‚Çö 1b‚Çö = 0b
xor·µá 1b‚Çö 0b‚Çö = 1b
xor·µá 1b‚Çö 1b‚Çö = 0b

_xor_ : Bits n ‚Üí Bits n ‚Üí Bits n
_xor_ = zipWith xor·µá

-- bit adder
add·µá : (c x y : Bit) ‚Üí Œ£ Bit Œª carry ‚Üí Bit
add·µá 0b‚Çö 0b‚Çö y   = 0b , y
add·µá 1b‚Çö 0b‚Çö 0b‚Çö = 0b , 1b
add·µá 1b‚Çö 0b‚Çö 1b‚Çö = 1b , 0b
add·µá 0b‚Çö 1b‚Çö 0b‚Çö = 0b , 1b
add·µá 0b‚Çö 1b‚Çö 1b‚Çö = 1b , 0b
add·µá 1b‚Çö 1b‚Çö 0b‚Çö = 1b , 0b
add·µá 1b‚Çö 1b‚Çö 1b‚Çö = 1b , 1b

_+_ : Bits n ‚Üí Bits n ‚Üí Œ£ Bit Œª carry ‚Üí Bits n
x + y = (x +‚Ä≤ y) 0b
  where
  _+‚Ä≤_ : Bits n ‚Üí Bits n ‚Üí Bit ‚Üí Œ£ Bit Œª carry ‚Üí Bits n
  ([]       +‚Ä≤ []      ) c = c , []
  ((x ‚à∑ xs) +‚Ä≤ (y ‚à∑ ys)) c with add·µá c x y
  ... | c‚ÇÅ , r with (xs +‚Ä≤ ys) c‚ÇÅ
  ... | c‚Ä≤ , rs = c‚Ä≤ , r ‚à∑ rs

ByteArray : ‚Ñï ‚Üí Type‚ÇÄ
ByteArray = Vec Byte

record Serializable (A : Type ‚Ñì) (len : ‚Ñï) : Type ‚Ñì where
  field
    encode        : A             ‚Üí ByteArray len
    decode        : ByteArray len ‚Üí Maybe A
    decode‚àòencode : (x : A) ‚Üí
                    decode (encode x) ‚â° just x
    encode‚àòdecode : (b : ByteArray len) {x : A} ‚Üí (decode b ‚â° just x) ‚Üí
                    b ‚â° encode x

BytePtr : ‚Ñï ‚Üí Type‚ÇÄ
BytePtr = Fin

single : ByteArray 1 ‚Üí Byte
single (x ‚à∑ _) = x

memset : Byte ‚Üí ByteArray n
memset = replicate

private
  instance
    ‚â§-dec : {p : T (m ‚â§·µá n)} ‚Üí m ‚â§ n
    ‚â§-dec {p = p} = ‚â§·µá‚áí‚â§ _ _ p

split‚â• : {w : ‚Ñï} {p : Fin n} ‚Üí
         n ‚â• w +Ãá to‚Ñï p ‚Üí
         Œ£ ‚Ñï Œª pre ‚Üí Œ£ ‚Ñï Œª post ‚Üí n ‚â° pre +Ãá (w +Ãá post)
split‚â• {n} {w} {p} x = to‚Ñï p , (n ‚à∏ (w +Ãá to‚Ñï p)) , lemma
  where
  lemma : n ‚â° to‚Ñï p +Ãá (w +Ãá (n ‚à∏ (w +Ãá to‚Ñï p)))
  lemma =
    begin
      n
    ‚â°Àò‚ü® m‚à∏n+n‚â°m x ‚ü©
      (n ‚à∏ (w +Ãá to‚Ñï p)) +Ãá (w +Ãá to‚Ñï p)
    ‚â°‚ü® cong (n ‚à∏ (w +Ãá to‚Ñï p) +Ãá_) (+-comm w _) ‚ü©
      (n ‚à∏ (w +Ãá to‚Ñï p)) +Ãá (to‚Ñï p +Ãá w)
    ‚â°Àò‚ü® +-comm (to‚Ñï p +Ãá w) _ ‚ü©
      (to‚Ñï p +Ãá w) +Ãá (n ‚à∏ (w +Ãá to‚Ñï p))
    ‚â°‚ü® +-assoc (to‚Ñï p) _ _ ‚ü©
      to‚Ñï p +Ãá (w +Ãá (n ‚à∏ (w +Ãá to‚Ñï p)))
    ‚àé where open ‚â°-Reasoning

slice_at_as_ : (a : ByteArray n) (p : BytePtr n) (width : ‚Ñï) ‚¶É prf : n ‚â• width +Ãá to‚Ñï p ‚¶Ñ ‚Üí ByteArray width
slice_at_as_ a p width ‚¶É prf ‚¶Ñ with split‚â• prf
... | pre , _ , spl = take width (drop pre (subst ByteArray spl a))

deref_inside_ : (p : BytePtr n) (a : ByteArray n) ‚Üí Byte
deref_inside_ zero    (x ‚à∑ _ ) = x
deref_inside_ (suc p) (x ‚à∑ xs) = deref p inside xs

memmove : {m n : ‚Ñï} ‚¶É p : m ‚â• n ‚¶Ñ (dst : ByteArray m) (src : ByteArray n) ‚Üí ByteArray m
memmove           dst       []        = dst
memmove ‚¶É s‚â§s p ‚¶Ñ (_ ‚à∑ dst) (x ‚à∑ src) = x ‚à∑ memmove ‚¶É p ‚¶Ñ dst src

private
  module Test where
  
    _ : memset {2} 0byte ‚â° 0byte ‚à∑ 0byte ‚à∑ []
    _ = refl

    all1byte : Byte
    all1byte = replicate 1b

    _ : memmove (0byte ‚à∑ 0byte ‚à∑ []) (all1byte ‚à∑ []) ‚â° all1byte ‚à∑ 0byte ‚à∑ []
    _ = refl

#+end_src
